// üìä Vulnerability Index Calculator - √çndice de Vulnerabilidade Socioambiental Composto
export interface VulnerabilityFactors {
  heatIslandIntensity: number; // 0-100
  floodRisk: number; // 0-100
  vegetationLoss: number; // 0-100
  socialVulnerability?: number; // 0-100 (opcional)
  airQuality?: number; // 0-100 (opcional)
}

export interface VulnerabilityResult {
  overallScore: number; // 0-100
  level: 'BAIXO' | 'MODERADO' | 'ALTO' | 'CR√çTICO';
  color: string;
  factors: VulnerabilityFactors;
  recommendations: string[];
  breakdown: {
    environmental: number;
    climatic: number;
    social: number;
  };
}

export class VulnerabilityCalculator {
  /**
   * Calcula √≠ndice de vulnerabilidade composto
   */
  static calculate(factors: VulnerabilityFactors): VulnerabilityResult {
    // Pesos dos fatores (totalizam 100%)
    const weights = {
      heatIslandIntensity: 0.30,
      floodRisk: 0.25,
      vegetationLoss: 0.20,
      socialVulnerability: 0.15,
      airQuality: 0.10
    };

    // Calcular score ponderado
    let totalScore = 0;
    let totalWeight = 0;

    totalScore += factors.heatIslandIntensity * weights.heatIslandIntensity;
    totalWeight += weights.heatIslandIntensity;

    totalScore += factors.floodRisk * weights.floodRisk;
    totalWeight += weights.floodRisk;

    totalScore += factors.vegetationLoss * weights.vegetationLoss;
    totalWeight += weights.vegetationLoss;

    if (factors.socialVulnerability !== undefined) {
      totalScore += factors.socialVulnerability * weights.socialVulnerability;
      totalWeight += weights.socialVulnerability;
    }

    if (factors.airQuality !== undefined) {
      totalScore += factors.airQuality * weights.airQuality;
      totalWeight += weights.airQuality;
    }

    const overallScore = totalScore / totalWeight;

    // Determinar n√≠vel
    let level: VulnerabilityResult['level'];
    let color: string;

    if (overallScore < 25) {
      level = 'BAIXO';
      color = '#00e676'; // Verde
    } else if (overallScore < 50) {
      level = 'MODERADO';
      color = '#ffd600'; // Amarelo
    } else if (overallScore < 75) {
      level = 'ALTO';
      color = '#ff6d00'; // Laranja
    } else {
      level = 'CR√çTICO';
      color = '#ff1744'; // Vermelho
    }

    // Breakdown por categoria
    const breakdown = {
      environmental: (factors.vegetationLoss * 0.6 + (factors.airQuality || 0) * 0.4),
      climatic: (factors.heatIslandIntensity * 0.6 + factors.floodRisk * 0.4),
      social: factors.socialVulnerability || 0
    };

    // Gerar recomenda√ß√µes
    const recommendations = this.generateRecommendations(factors, overallScore);

    return {
      overallScore: Math.round(overallScore * 10) / 10,
      level,
      color,
      factors,
      recommendations,
      breakdown
    };
  }

  /**
   * Gera recomenda√ß√µes baseadas nos fatores
   */
  private static generateRecommendations(
    factors: VulnerabilityFactors,
    overallScore: number
  ): string[] {
    const recommendations: string[] = [];

    // Recomenda√ß√µes gerais baseadas no score
    if (overallScore >= 75) {
      recommendations.push('üö® URGENTE: Implementar plano de a√ß√£o emergencial para mitiga√ß√£o de riscos');
    } else if (overallScore >= 50) {
      recommendations.push('‚ö†Ô∏è Desenvolver estrat√©gias de m√©dio prazo para redu√ß√£o de vulnerabilidade');
    }

    // Recomenda√ß√µes espec√≠ficas por fator
    if (factors.heatIslandIntensity > 60) {
      recommendations.push('üå≥ Aumentar cobertura arb√≥rea em 20-30% para mitigar ilhas de calor');
      recommendations.push('üèóÔ∏è Promover telhados e fachadas verdes em edif√≠cios p√∫blicos');
    }

    if (factors.floodRisk > 60) {
      recommendations.push('üíß Implementar sistemas de drenagem sustent√°vel (SuDS) prioritariamente');
      recommendations.push('üèûÔ∏è Criar √°reas de reten√ß√£o e infiltra√ß√£o de √°guas pluviais');
    }

    if (factors.vegetationLoss > 60) {
      recommendations.push('üå± Estabelecer corredores ecol√≥gicos e √°reas de preserva√ß√£o permanente');
      recommendations.push('üìã Revisar zoneamento para prote√ß√£o de √°reas verdes remanescentes');
    }

    if (factors.socialVulnerability && factors.socialVulnerability > 60) {
      recommendations.push('üèòÔ∏è Priorizar investimentos em infraestrutura urbana nas √°reas cr√≠ticas');
      recommendations.push('üë• Implementar programas de educa√ß√£o ambiental comunit√°ria');
    }

    if (factors.airQuality && factors.airQuality > 60) {
      recommendations.push('üöó Incentivar transporte p√∫blico e mobilidade ativa');
      recommendations.push('üè≠ Monitorar e regular emiss√µes de fontes poluidoras');
    }

    // Recomenda√ß√£o de monitoramento sempre
    recommendations.push('üìä Estabelecer sistema de monitoramento cont√≠nuo de indicadores ambientais');

    // Limitando a 6 recomenda√ß√µes mais importantes
    return recommendations.slice(0, 6);
  }

  /**
   * Converte dados de an√°lise para fatores de vulnerabilidade
   */
  static fromAnalysisData(data: {
    avgAnnualTemperature?: number;
    avgTemperature?: number; // legacy support
    vegetationDensity: number;
    floodRisk: string;
    heatIslandRisk?: string;
    droughtRisk?: string;
    socialVulnerability?: string;
  }): VulnerabilityFactors {
    // Temperatura: normalizar para 0-100
    // Considerando 20¬∞C como ideal (0) e 40¬∞C como cr√≠tico (100)
    const avgTemp = data.avgAnnualTemperature ?? data.avgTemperature ?? 28;
    const tempScore = Math.min(100, Math.max(0, 
      ((avgTemp - 20) / 20) * 100
    ));

    // Vegeta√ß√£o: inverter (mais vegeta√ß√£o = menos vulnerabilidade)
    const vegLoss = 100 - data.vegetationDensity;

    // Risco de alagamento: converter string para n√∫mero
    const floodRiskMap: Record<string, number> = {
      'LOW': 20,
      'MEDIUM': 50,
      'HIGH': 75,
      'CRITICAL': 95
    };
    const floodScore = floodRiskMap[data.floodRisk] || 50;

    // Vulnerabilidade social (se dispon√≠vel)
    const socialScore = data.socialVulnerability 
      ? floodRiskMap[data.socialVulnerability] || 50
      : undefined;

    return {
      heatIslandIntensity: tempScore,
      floodRisk: floodScore,
      vegetationLoss: vegLoss,
      socialVulnerability: socialScore
    };
  }

  /**
   * Compara dois per√≠odos e retorna varia√ß√£o
   */
  static comparePeroids(
    before: VulnerabilityResult,
    after: VulnerabilityResult
  ): {
    scoreDelta: number;
    improving: boolean;
    significantChange: boolean;
    message: string;
  } {
    const scoreDelta = after.overallScore - before.overallScore;
    const improving = scoreDelta < 0;
    const significantChange = Math.abs(scoreDelta) > 10;

    let message = '';
    if (improving) {
      message = significantChange 
        ? `‚úÖ Melhoria significativa detectada (-${Math.abs(scoreDelta).toFixed(1)} pontos)`
        : `‚ÜóÔ∏è Leve melhoria na vulnerabilidade (-${Math.abs(scoreDelta).toFixed(1)} pontos)`;
    } else {
      message = significantChange
        ? `üö® Deteriora√ß√£o significativa detectada (+${scoreDelta.toFixed(1)} pontos)`
        : `‚ÜòÔ∏è Leve aumento na vulnerabilidade (+${scoreDelta.toFixed(1)} pontos)`;
    }

    return {
      scoreDelta,
      improving,
      significantChange,
      message
    };
  }

  /**
   * Gera dados para gr√°fico radar
   */
  static toRadarChartData(result: VulnerabilityResult): Array<{
    axis: string;
    value: number;
    fullMark: number;
  }> {
    return [
      {
        axis: 'Ilhas de Calor',
        value: result.factors.heatIslandIntensity,
        fullMark: 100
      },
      {
        axis: 'Risco de Alagamento',
        value: result.factors.floodRisk,
        fullMark: 100
      },
      {
        axis: 'Perda de Vegeta√ß√£o',
        value: result.factors.vegetationLoss,
        fullMark: 100
      },
      {
        axis: 'Vulnerabilidade Social',
        value: result.factors.socialVulnerability || 0,
        fullMark: 100
      },
      {
        axis: 'Qualidade do Ar',
        value: result.factors.airQuality || 0,
        fullMark: 100
      }
    ];
  }
}
